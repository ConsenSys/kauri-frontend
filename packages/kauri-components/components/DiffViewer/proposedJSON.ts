const text = {
  markdown:
    '## Set up a new development environment\n\nTo get started developing DApps with GoLang (also known as Go), firstly [install the Ethereum toolchain](https://github.com/ethereum/go-ethereum/wikia/Building-Ethereum-DAPP).\n\nNext create a new folder to contain the project, for this guide, we assume that the project location is `/go/go-geth-dapp-demo`. \n\n ## Another headline  \n\n## Manage Go dependencies\n\nWe use [Go modules](https://github.com/golang/go/wikia/) to manage dependencies for this project. To get starting using Go modules for this project:\n\nOpen the terminal navigate to the project folder, and in the project folder, run:\n\n```\ngo mod init github.com/<github-username>/geth-dapp-demo\n```\n\nEdit the resulting `go.mod` file to look like the following, and save the file:\n\n```\nmodule github.com/<username>/geth-dapp-demo\n\nrequire (\n    github.com/ethereum/go-ethereum v1.9.10\n    github.com/joho/godotenv v1.3.0\n)\n```\n\nWhen building an application, Go automatically fills the `go.mod` file with the other dependencies needed. We can let Go take care of those for now. With the `go.mod` file in place, Go makes sure that we use `v1.9.10` of the Go Ethereum SDK whenever we run the `go run` or `go build` command.\n\n### Set up Rinkeby testnet endpoint on Infura.io\n\nTo keep this guide straightforward, we use the Ethereum API gateways provided by [Infura.io](https://infura.io) instead of running our own Ethereum node. To run a Geth node for development instead, read this [Ethereum 101 guide](https://beta.kauri.io/article/67a81d8746ee4b49ba19447e8e2a983e/v5).\n\n1.  Go to [Infura.io](https://infura.io) and sign up for an account.\n2.  Go to the Dashboard and click on **CREATE NEW PROJECT**.\n3.  Enter a name for the project, and click **CREATE** to set up a new project.\n\nThe newly created project should look like this:\n\n![New project on Infura.io](https://api.beta.kauri.io:443/ipfs/QmSXXdatWZMkp63Hu4BYtgmNHTp75TD3Mm2BGxauFBhkYT)\n\nWe\'ll come back to this later when we\'ve deployed the smart contract.\n\nFor now, we need the URL of our project\'s Ethereum API gateway endpoint. Select "RINKEBY" from the **ENDPOINT** dropdown menu, and take note of the URL that appears underneath it. It should look like this:\n\n    https://rinkeby.infura.io/v3/<PROJECT_ID>\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lorem ipsum, laoreet quis diam sit amet, tempor sodales elit. Integer sed sem ut mi efficitur malesuada. Duis mattis nunc in turpis consequat, quis dictum diam suscipit. Sed aliquet, magna eu pulvinar faucibus, nunc libero lobortis ante, a ultricies neque mi eu nibh. Praesent rhoncus iaculis risus sit amet dignissim. Pellentesque finibus lectus non urna hendrerit, semper blandit lorem volutpat. Praesent porta nulla nisi. \n**IMPORTANT!:** Make sure that the endpoint used in the Go code points to the Rinkeby testnet. If we use an endpoint pointing to the Ethereum mainnet, we spend real Ether to test the application.\n\nCreate a file in the project folder named `.env`. **Do not** commit this file to Git or any other version control system (VCS). Edit the `.env` file and enter the project\'s Ethereum API gateway endpoint:\n\n```\nGATEWAY="https://rinkeby.infura.io/v3/<PROJECT_ID>"\n```\n\nSave the file. We\'ll use this into our Go application later.\n\n**NOTE:** Using a third-party provider to connect to the Ethereum network means that we\'re trusting it with all transactions and any Ether sent through it. If we don\'t use a third-party provider, we have to run and host our own Ethereum API gateway, or rely on users to connect to their own Ethereum nodes.\n\n### Set up an Ethereum account\n\nWe need an Ethereum account to deploy our smart contract. To create a new Ethereum account, run the command below and follow the on-screen instructions:\n\n```\ngeth --datadir . account new\n```\n\nThis command creates a `keystore` folder in the current directory. In it, is a keystore file for the new account that looks like `UTC--<timestamp>--<ethereum_address>`. **Do not** commit the keystore to VCS.\n\nWe need this keystore file and the passphrase for it to deploy a smart contract. Save the location of the keystore file and the passphrase in the `.env` file created earlier:\n\n```javascript\nGATEWAY="..."\nKEYSTORE="$HOME/.ethereum/keystore/<your-keystore-file>"\nKEYSTOREPASS="<keystore_passphrase>"\n```\n\nTo deploy a contract and make contract calls; we need our account to contain Rinkeby testnet Ether. Get testnet Ether for the account by going to <https://faucet.rinkeby.io> and following the instructions there.\n\n## Writing and compiling the smart contract\n\nWe\'re all set and ready to go! First, we write the smart contract:\n\n1.  Create a new folder in the project directory and name it `quiz`.\n2.  In it, create a file named `quiz.sol` and add the following code:\n\n```solidity\npragma solidity >=0.5.2 <0.6.0;\n\ncontract Quiz {\n    string public question;\n    bytes32 internal _answer;\n    mapping (address => bool) internal _leaderBoard;\n\n    constructor(string memory _qn, bytes32 _ans) public {\n        question = _qn;\n        _answer = _ans;\n    }\n\n    function sendAnswer(bytes32 _ans) public returns (bool){\n        return _updateLeaderBoard(_answer == _ans);\n    }\n\n    function _updateLeaderBoard(bool ok) internal returns (bool){\n        _leaderBoard[msg.sender] = ok;\n        return true;\n    }\n\n    function checkBoard() public view returns (bool){\n        return _leaderBoard[msg.sender];\n    }\n}\n```\n\nWe\'ll cover what our smart contract code does briefly, for more information about writing smart contracts in Solidity, read [this guide](https://beta.kauri.io/article/124b7db1d0cf4f47b414f8b13c9d66e2/v5).\n\nFirst, we set the data types that we want to store on the contract.\n\n`string public question`: Stores the question that we want to ask the user. Setting this as `public` has Solidity automatically generate a getter function for it when the contract compiles. This allows us to read this variable\'s contents with a `contractInstance.question()` method. Because getters don\'t invoke code execution on the EVM, they don\'t cost gas to run.\n\n`bytes32 internal _answer`: Stores the answer to our question. We\'ve set an `internal` modifier, which means that this variable can only be accessed from within this contract.\n\n`mapping (address=>bool) internal _leaderBoard`: Stores a hash map of user accounts and a boolean value that tells us whether a given account has answered the question correctly. We\'ve also set this state variable as `internal` to prevent external callers from modifying its contents.\n\nNext, the `constructor` is called when we deploy the contract where we give it a question `_qn` and an answer `_ans`.\n\nWe take `_qn` as a string because we mean for it to be easily readable by anyone interacting with the contract.\n\nOur answer `_ans` is set as a fixed slice of 32 bytes (`bytes32`) because we want to store it as a `keccak256` hash. Hashing the value of `_ans` obscures it, making it unreadable in the contract source or the transaction logs.\n\n`sendAnswer()` allows us to send an answer to the contract. The answer sent to the contract must be a 32-byte keccak256 hash, which we compare to the value of `_answer` stored on the contract. If the values match, we update our `leaderBoard` to show that the account that makes this function call has answered correctly.\n\n`_updateLeaderBoard()` takes a true/false value and sets the entry on the `_leaderBoard` mapping for our user\'s account to that value. It\'s an `internal` function, which prevents external callers from arbitrarily modifying the `_leaderBoard` mapping.\n\n`checkBoard()` checks if the contract recorded that the user answered correctly. The current user\'s Ethereum account is set by our `KEYSTORE` environment variable in [Set up an Ethereum account](#set-up-an-ethereum-account)\n\nNow that we\'ve got our Solidity contract fleshed out, we need to compile it to an ABI JSON specification and a contract binary. Then, we\'ll generate a Go binding file from those files, and import it into our Go DApp.\n\nWe\'ll use `solc` and `abigen` to do this. Run the following command to compile the contract:\n\n```\nsolc --abi --bin quiz.sol -o build\n```\n\nThis command creates a `build` folder that contains the files `Quiz.abi` and `Quiz.bin`.\n\nNext, generate the Go binding file. In the "quiz" directory, run:\n\n```\nabigen --abi="build/Quiz.abi" --bin="build/Quiz.bin" --pkg=quiz --out="quiz.go"\n```\n\nThis command generates a Go file that contains bindings for the smart contract which we can import into our Go code.\n\n## The Go Code\n\n### Connect to Rinkeby network and get account balance\n\nWe\'ll start writing our Go DApp by initializing a connection to the Rinkeby network, using the Infura.io gateway endpoint that we [set up earlier](#set-up-rinkeby-testnet-endpoint-on-infuraio).\n\nIn the project root directory, create a new `main.go` file and add the following code:\n\n```\npackage main\n\nimport (\n    "context"\n    "log"\n    "fmt"\n\n    "github.com/ethereum/go-ethereum"\n    "github.com/joho/godotenv"\n)\n\nvar myenv map[string]string\n\nconst envLoc = ".env"\n\nfunc loadEnv() {\n    var err error\n    if myenv, err = godotenv.Read(envLoc); err != nil {\n        log.Printf("could not load env from %s: %v", envLoc, err)\n    }\n}\n\nfunc main(){\n    loadEnv()\n\n    ctx := context.Background()\n\n    client, err := ethclient.Dial(os.Getenv("GATEWAY"))\n    if err != nil {\n        log.Fatalf("could not connect to Ethereum gateway: %v\\n", err)\n    }\n    defer client.Close()\n\n    accountAddress := common.HexToAddress("<enter_ethereum_address>")\n    balance, _ := client.BalanceAt(ctx, accountAddress, nil)\n    fmt.Printf("Balance: %d\\n",balance)\n}\n```\n\nReplace `<enter_ethereum_address>` with the address of the Ethereum account from the [Set up an Ethereum account](#set-up-an-ethereum-account) step.\n\nHere, we:\n\nFirst load data from the `.env` file into a map `myenv` using the `godotenv` package, which we set as a dependency in our `go.mod` file.\n\nWe can then access values set in our `.env` file with `myenv["KEYNAME"]`. For example, access the `GATEWAY` value with `myenv["GATEWAY"]`.\n\nNotice that we\'ve also written a function `loadEnv()` that we can invoke at the beginning of every function scope. By placing a `loadEnv()` call at the start of every function that uses environment variables, we make sure that we catch any updates to our `.env` file while our application is running.\n\nNext we set up a connection to our Infura.io Rinkeby gateway by calling `ethclient.Dial("<gateway_endpoint>")`. This works for both TCP (HTTP/S) and IPC (`<datadir>/geth.ipc`) endpoints. Then get the balance of our Ethereum account by calling `client.GetBalance(ctx, accountAddress, nil)` to convert our Ethereum address from a hex string like `48fddc985ecc605127f1a1c098c817778187637c` to the `common.Address` type before passing it to `GetBalance()` and print the result of `GetBalance()`.\n\nTest the application by running `go run main.go` in the terminal. If it prints the balance of the Ethereum account, the application has successfully loaded configuration from the `.env` file and sent a message call to the Rinkeby network.\n\nNow that we know that our `ethclient.Dial()` call works, we won\'t need the `GetBalance()` call. Remove it from `main()`, so that your main() block looks like this:\n\n```\nfunc main(){\n    loadEnv()\n\n    ctx := context.Background()\n\n    client, err := ethclient.Dial(os.Getenv("GATEWAY"))\n    if err != nil {\n        log.Fatalf("could not connect to Ethereum gateway: %v\\n", err)\n    }\n    defer client.Close()\n\n}\n```\n\n### Create session\n\nSessions are wrappers that allow us to make contract calls without having to pass around authorization credentials and call parameters constantly. A session wraps:\n\n- a contract instance,\n- a `bind.CallOpts` struct that contains options for making contract calls,\n- a `bind.TransactOpts` struct that contains authorization credentials and parameters for creating a valid Ethereum transaction.\n\nCreating a session allows us to make calls on a contract instance like this:\n\n```\nauth, _ := bind.NewTransactor(keystorefile, keystorepass)\nsession.TransactOpts = auth\n\n// This calls the contract method sendAnswer(),\n// which returns the question that we\'ve set\n// for our deployed contract.\nsession.SendAnswer(answer)\nsession.Question()\n```\n\nAs opposed to having to pass in a `bind.CallOpts` or `bind.TransactOpts` struct each time we make a contract call or a transaction:\n\n```\nauth, _ := bind.NewTransactor(keystorefile, keystorepass)\ncontractInstance.SendAnswer(&bind.TransactOpts{\n        From: auth.From,\n        Nonce: nil,           // nil uses nonce of pending state\n        Signer: auth.Signer,\n        Value: big.NewInt(0),\n        GasPrice: nil,        // nil automatically suggests gas price\n        GasLimit: 0,          // 0 automatically estimates gas limit\n    },\n    answer,\n    )\ncontractInstance.Question(&bind.CallOpts{\n    Pending: true,\n    From: auth.From,\n    Context: context.Background(),\n})\ncontractInstance.CheckBoard(&bind.CallOpts{\n    Pending: true,\n    From: auth.From,\n    Context: context.Background(),\n})\n```\n\nInstead, we do it once when we create a new session:\n\n```\nauth, _ := bind.NewTransactor(keystorefile, keystorepass)\nsession := quiz.QuizSession{\n    Contract: contractInstance,\n    CallOpts: bind.CallOpts{\n        Pending: true,        // Acts on pending state if set to true\n        From: auth.From,\n        Context: context.Background(),\n    },\n    TransactOpts: bind.TransactOpts{\n        From: auth.From,\n        Nonce: nil,           // nil uses nonce of pending state\n        Signer: auth.Signer,\n        Value: big.NewInt(0),\n        GasPrice: nil,        // nil automatically suggests gas price\n        GasLimit: 0,          // 0 automatically estimates gas limit\n    },\n}\n\nsession.SendAnswer(answer)\nsession.Question()\nsession.CheckBoard()\n```\n\n**NOTE:** `bind.NewTransactor()` returns a `bind.TransactOpts` struct with the `From` and `Signer` fields filled in with information from the keystore file, and the other fields filled in with safe defaults. We can use it as-is for transactions. For example `contractInstance.SendAnswer(auth, answer)` also works for our above example.\n\nLet\'s create a `NewSession()` function that creates a new usable session and returns it, add this to the bottom of your `main.go` file:\n\n```\nfunc NewSession(ctx context.Context) (session quiz.QuizSession) {\n    loadEnv()\n    keystore, err := os.Open(myenv["KEYSTORE"])\n    if err != nil {\n        log.Printf(\n            "could not load keystore from location %s: %v\\n",\n            myenv["KEYSTORE"],\n            err,\n        )\n    }\n    defer keystore.Close()\n\n    keystorepass := myenv["KEYSTOREPASS"]\n    auth, err := bind.NewTransactor(keystore, keystorepass)\n    if err != nil {\n        log.Printf("%s\\n", err)\n    }\n\n    // Return session without contract instance\n    return quiz.QuizSession{\n        TransactOpts: *auth,\n        CallOpts: bind.CallOpts{\n            From:    auth.From,\n            Context: ctx,\n        },\n    }\n}\n```\n\nHere, we:\n\n- Load our environment variables from `.env`.\n- Read from our keystore file.\n- Get our keystore passphrase from the environment variable `KEYSTOREPASS`.\n- Create a new transactor with a `bind.NewTransactor()` call.\n- Form and return a new `quiz.QuizSession` struct with our newly created transactor and a `CallOpts` struct with some defaults.\n\nWe can then create a new session in `main()`:\n\n```\nfunc main(){\n    // ...\n    session := NewSession(context.Background())\n}\n```\n\nWe didn\'t specify a value for the `Contract` field in the session that we\'re returning from `NewSession()`. We\'ll do that on the returned `session` after we\'ve obtained a contract instance which we when we deploy a new contract on the blockchain or when we load an existing contract.\n\n### Deploy and load the contract\n\nNow that we\'ve created a new session, we need to assign it a contract instance.\n\nWe get a contract instance by deploying a contract or loading an existing contract from a contract address.\n\nWe\'ll write two functions to perform these tasks:\n\n```\n// NewContract deploys a contract if no existing contract exists\nfunc NewContract(session quiz.QuizSession, client *ethclient.Client, question string, answer string) (quiz.QuizSession) {\n    loadEnv()\n\n    // Hash answer before sending it over Ethereum network.\n    contractAddress, tx, instance, err := quiz.DeployQuiz(&session.TransactOpts, client, question, stringToKeccak256(answer))\n    if err != nil {\n        log.Fatalf("could not deploy contract: %v\\n", err)\n    }\n    fmt.Printf("Contract deployed! Wait for tx %s to be confirmed.\\n", tx.Hash().Hex())\n\n    session.Contract = instance\n    updateEnvFile("CONTRACTADDR", contractAddress.Hex())\n    return session\n}\n\n// LoadContract loads a contract if one exists\nfunc LoadContract(session quiz.QuizSession, client *ethclient.Client) quiz.QuizSession {\n    loadEnv()\n\n    addr := common.HexToAddress(myenv["CONTRACTADDR"])\n    instance, err := quiz.NewQuiz(addr, client)\n    if err != nil {\n        log.Fatalf("could not load contract: %v\\n", err)\n        log.Println(ErrTransactionWait)\n    }\n    session.Contract = instance\n    return session\n}\n\n// Utility functions\n\n// stringToKeccak256 converts a string to a keccak256 hash of type [32]byte\nfunc stringToKeccak256(s string) [32]byte {\n    var output [32]byte\n    copy(output[:], crypto.Keccak256([]byte(s))[:])\n    return output\n}\n\n// updateEnvFile updates our env file with a key-value pair\nfunc updateEnvFile(k string, val string) {\n    myenv[k] = val\n    err := godotenv.Write(myenv, envLoc)\n    if err != nil {\n        log.Printf("failed to update %s: %v\\n", envLoc, err)\n    }\n}\n```\n\nBoth `NewContract()` and `LoadContract()` create a contract instance, which we then assign to the `Contract` in the session with `session.Contract = instance`. We then return the session.\n\n#### Deploy a new contract\n\nOur `NewContract()` function takes as parameters:\n\n- `session quiz.QuizSession`: a session, which we initialized in [Create session](#create-session).\n- `client *ethclient.Client`: the client object, which we initialized in `main()`.\n- `question string`: a string containing the question we want the user to answer.\n- `answer string`: the answer to the question, which we take as a string parameter.\n\nWe have to find a way to pass strings to our contract as the `question` and `answer` parameters, but we don\'t want to hardcode our answer or commit a file containing the answer to VCS. If we do, a user looking at the contract source or our DApp source code would be able to find the expected value for `answer` stored as plain text.\n\nWe also don\'t want to send the value of `answer` to the contract as plain text, because the contents of all transactions broadcasted to the network are logged as part of the transaction\'s payload. Any values sent as plain text would appear as-is when viewing the transaction\'s payload.\n\nSee an example of this at [`0x445d51fc29741b261f392936970b3c842e922dec841023ca40e248b9d3a2ba19`](https://rinkeby.etherscan.io/tx/0x445d51fc29741b261f392936970b3c842e922dec841023ca40e248b9d3a2ba19) on the Rinkeby network.\n\n![Answer stored as plain text](https://api.beta.kauri.io:443/ipfs/QmNZf2x1NDCWzSWvqus3dDeDmcUtp4U4GVpH6pKR9m8Z3z)\n\nTo get around this, we do two things:\n\nWe\'re already loading values from a `.env` file, so we can use that to store our `question` and `answer` values.\n\nAdd a `QUESTION` and an `ANSWER` key-value pair. Make the following changes to the `.env`:\n\n```\nGATEWAY="..."\nKEYSTORE="..."\nKEYSTOREPASS="..."\nQUESTION="this is a question"\nANSWER="this is the answer"\n```\n\nAfter we\'ve done that, we can load the `question` and `answer` values in our code using `myenv["QUESTION"]` and `myenv["ANSWER"]` respectively.\n\nNext, encode the value of `answer` as a Keccak256 hash before sending it as part of the `session.DeployQuiz()` call. We can use the utility function `stringToKeccak256()` that converts a given string to keccak256 hash of type `[32]byte`.\n\nWe can now run `quiz.DeployQuiz()` and obtain a contract address `contractAddress`, a transaction object `tx`, and a contract instance `instance`. We assign the contract instance to `session.Contract` and return the now fully-formed session.\n\nWe also print the address of the transaction, which the user can look up on [Etherscan](https://rinkeby.etherscan.io) to check the progress of the transaction.\n\nFinally, we need to save the address of the deployed contract. We save it to our `.env` file by using the `godotenv.Write()` method. Here, we use another utility function `updateEnvFile()` to help us do this. `updateEnvFile()` does the following:\n\n1.  Adds a key `CONTRACTADDR` to our `myenv` map, and assigns the contract address hex to it.\n2.  Calls `godotenv.Write(myenv, envLoc)` to write the updated `myenv` map to our `.env` file.\n\n#### Load an existing contract\n\nThe `LoadContract()` function also takes a `session` and `client` instance as parameters. Then, it attempts to load an existing contract by looking for a `CONTRACTADDR` entry in the `.env` file.\n\nIf a `CONTRACTADDR` doesn\'t exist in the `.env` file, we won\'t know where to locate our contract on the blockchain, so exit the function.\n\nOtherwise, call `quiz.NewQuiz()` to create a new contract instance and assign it to `session.Contract`.\n\n#### Deploy if the contract doesn\'t exist\n\nWe only want to call `NewContract()` if we don\'t already have an existing contract on the blockchain.\n\nTo do this, we write `if` statements to make sure that `NewContract()` is only called when `CONTRACTADDR` is not set in our `.env` file, and run `LoadContract()` only if we can find a non-empty `CONTRACTADDR` value:\n\n```\nfunc main() {\n    // ...\n    // Load or Deploy contract, and update session with contract instance\n    if myenv["CONTRACTADDR"] == "" {\n        session = NewContract(session, client, myenv["QUESTION"], myenv["ANSWER"])\n    }\n\n    // If we have an existing contract, load it; if we\'ve deployed a new contract, attempt to load it.\n    if myenv["CONTRACTADDR"] != "" {\n        session = LoadContract(session, client)\n    }\n}\n```\n\n**NOTE:** Once we do this, the DApp attempts to load a contract from the value of `CONTRACTADDR` in the `.env` file as long as that value is not an empty string (`""`). To force the DApp to deploy a new contract, remove the `CONTRACTADDR` entry in the `.env` file, or set it to an empty string (`""`).\n\n### Interact with the contract\n\nNow that we have a contract instance to work with, we can use it to make contract calls.\n\nAny function or state variable marked as `public` in the `quiz.go` file generated with `abigen` is made available in `quiz.go` as methods we can call on a contract instance.\n\nFor example, because we have this line of code in `quiz.sol`:\n\n```\nfunction sendAnswer(bytes32 _ans) public returns (bool)\n```\n\nImporting `quiz.go` in our Go DApp allows us to call:\n\n```\ncontractInstance.SendAnswer(&bind.CallOpts, answer)\n```\n\nRemember that we want to do [the following things](#structure-of-our-application) with our Go DApp:\n\n- Read the question.\n- Send an answer to the smart contract.\n- Check if the answer sent is correct.\n- If the answer sent is correct, record the user\'s account address.\n\nTo perform these tasks, we add the following functions to the bottom of the `main.go` file:\n\n```\n//// Contract interaction\n\n// ErrTransactionWait should be returned/printed when we encounter an error that may be a result of the transaction not being confirmed yet.\nconst ErrTransactionWait = "if you\'ve just started the application, wait a while for the network to confirm your transaction."\n\n// readQuestion prints out question stored in contract.\nfunc readQuestion(session quiz.QuizSession) {\n    qn, err := session.Question()\n    if err != nil {\n        log.Printf("could not read question from contract: %v\\n", err)\n        log.Println(ErrTransactionWait)\n        return\n    }\n    fmt.Printf("Question: %s\\n", qn)\n    return\n}\n\n// sendAnswer sends answer to contract as a keccak256 hash.\nfunc sendAnswer(session quiz.QuizSession, ans string) {\n    // Send answer\n    txSendAnswer, err := session.SendAnswer(stringToKeccak256(ans))\n    if err != nil {\n        log.Printf("could not send answer to contract: %v\\n", err)\n        return\n    }\n    fmt.Printf("Answer sent! Please wait for tx %s to be confirmed.\\n", txSendAnswer.Hash().Hex())\n    return\n}\n\n// checkCorrect makes a contract message call to check if\n// the current account owner has answered the question correctly.\nfunc checkCorrect(session quiz.QuizSession) {\n    win, err := session.CheckBoard()\n    if err != nil {\n        log.Printf("could not check leaderboard: %v\\n", err)\n        log.Println(ErrTransactionWait)\n        return\n    }\n    fmt.Printf("Were you correct?: %v\\n", win)\n    return\n}\n```\n\nHere, we write three helper functions to wrap our contract calls:\n\n- `readQuestion(session quiz.QuizSession)` reads the question we stored on our deployed smart contract, and prints it out.\n- `sendAnswer(session quiz.QuizSession, ans string)` takes an answer as a string, encodes it as a keccak256 hash, and sends it to the smart contract.\n- `checkCorrect(session quiz.QuizSession)` checks if the current user is recorded on our smart contract as having sent a correct answer.\n\nNow, we can call these functions in `main()` to interact with a deployed smart contract.\n\n### Write a simple CLI\n\nNext, we\'ll write a bare-bones command-line interface (CLI) to allow our user to:\n\n1.  Read the question.\n2.  Send an answer.\n3.  Check if their answer was correct.\n\nTo implement this, add the following to the bottom of the `main()` block:\n\n```\n// Loop to implement simple CLI\nfor {\n    fmt.Printf(\n        "Pick an option:\\n" + "" +\n            "1\\. Show question.\\n" +\n            "2\\. Send answer.\\n" +\n            "3\\. Check if you answered correctly.\\n" +\n            "4\\. Exit.\\n",\n    )\n\n    // Reads a single UTF-8 character (rune)\n    // from STDIN and switches to case.\n    switch readStringStdin() {\n    case \'1\':\n        readQuestion(session)\n        break\n    case \'2\':\n        fmt.Println("Type in your answer")\n        sendAnswer(session, readStringStdin())\n        break\n    case \'3\':\n        checkCorrect(session)\n        break\n    case \'4\':\n        fmt.Println("Bye!")\n        return\n    default:\n        fmt.Println("Invalid option. Please try again.")\n        break\n    }\n}\n```\n\nThen, add the following helper function to the bottom of the `main.go` file:\n\n```\n// readStringStdin reads a string from STDIN and strips any trailing \\n characters from it.\nfunc readStringStdin() string {\n    reader := bufio.NewReader(os.Stdin)\n    inputVal, err := reader.ReadString(\'\\n\')\n    if err != nil {\n        log.Printf("invalid option: %v\\n", err)\n        return ""\n    }\n\n    output := strings.TrimSuffix(inputVal, "\\n") // Important!\n    return output\n}\n```\n\nWhen we run the Go DApp with `go run main.go` in the terminal, `readStringStdin()` calls `bufio.NewReader(io.Stdin)`, which pauses the program and waits for the user to enter a value on the command line. It then takes that input, processes it, and returns it as a value that the Go application can use.\n\nWe implement the CLI using an infinite `for` loop that does the following:\n\n1.  Prints out quick instructions for using the CLI.\n2.  Enters a `switch` statement that reads from user input on the command line, and executes a given `case` for the appropriate `rune` it receives.\n3.  When the user selects an option, the code for that `case` runs and returns to the top of the `for` loop when `break` is called.\n\n## Running the application\n\nCongrats! We\'ve finished the quiz DApp!\n\nBefore testing the application, check that the `.env` file contains the values that the Go DApp needs to run. It should look something like this:\n\n```\nGATEWAY="https://rinkeby.infura.io/v3/<project_id>"\nKEYSTORE="/keystore/UTC--2019-01-14T13-58-48.439126200Z--<ethereum_address>"\nKEYSTOREPASS=""\nQUESTION="this is a question"\nANSWER="this is the answer"\n```\n\nTo run the Go DApp, enter in the terminal:\n\n```\ngo run main.go\n```\n\nAlternatively, build and run the Go DApp by running:\n\n```\ngo build main.go\n./main\n```\n\n## Limitations\n\nOur DApp is a simple example of what we can do with smart contracts and a Go DApp. Because we tried to keep the example straightforward, our DApp has a few limitations:\n\nOur DApp doesn\'t know if a transaction is completed or not. That\'s why we need separate functions to send an answer to the blockchain, and another to check if the answer was correct. We can implement this by having a process listen to any events on the blockchain at our contract address, but this is outside the scope of this guide.\n\nOur user can\'t just run the DApp, and it works. They need to specify a keystore file, and make sure that they have a deployed contract ready to interact with. We can correct this by adding to our CLI options that allow the user to enter values that configure these parameters.\n\nOur DApp assumes that the user who runs it is the same person who (1) deploys the contract, and (2) answers the question. Ideally, the DApp that deploys the contract and the DApp that interacts with the contract should be separate.',
};

export default text;
